# TypeScript Challenge Day4 (12/15)

## generic

제네릭이란 타입을 마치 함수의 파라미터처럼 사용하는 것을 의미.</br>
내가 요구하는 대로 콜 시그니쳐를 생성해줄 수 있는 도구

</br>

### generic을 활용하여 타입에 상관없이 배열의 요소를 출력하는 함수

<img width="310" alt="스크린샷 2022-12-16 오전 12 12 59" src="https://user-images.githubusercontent.com/94230809/207896857-5710afc4-faa5-4cd8-97b1-d36658efe80d.png">

</br>

여기서 우리는 문제점을 발견한다. </br>문제는 우리는 "타입과 상관없이" 배열의 요소를 출력하는 함수를 만드는것이 목적이다. </br>하지만 지금은 number타입의 배열만 가능하다.

그럼 우리는 콜시그니쳐에 추가해주는 작업을 할 것 이다.</br>

<img width="183" alt="스크린샷 2022-12-16 오전 12 13 52" src="https://user-images.githubusercontent.com/94230809/207897062-fe5fe31d-830c-4a80-861c-3aeacb645a56.png">

</br>
하지만 이렇게 일일히 하나하나 추가해주는 작업은 옳지 않다.</br>
만약 만약 배열안 요소가 전부 다른 타입이라면 어떻게 해야 될까 ?</br>
이 문제 또한 generic으로 해결할 수 있다.

</br>

그래서 우리는 타입스크립트에게 generic타입을 받으라고 알려줄 것 이다.</br>

generic타입은 placeholder같은 것이다.

</br>

### generic 사용방법

<img width="176" alt="스크린샷 2022-12-16 오전 12 17 15" src="https://user-images.githubusercontent.com/94230809/207897824-8b7d8078-5623-4ca0-9dcf-b9d1f8536532.png">

</br>
generic을 사용할 때는 먼저 콜시그니쳐가 generic을 받는다고 알려줘야한다.
</br>
그 동작은 받고자 하는 해당 argument앞에 <br>를 열고 그 안에 원하는 generic이름을 넣는다 뭐든 상관없다.
</br>
그리고 arr이 어떤 타입인지 명시하는곳에 해당 generic 이름을 넣는다.

</br>

<img width="526" alt="스크린샷 2022-12-16 오전 12 20 22" src="https://user-images.githubusercontent.com/94230809/207898582-367f4aaa-7407-46f0-9a47-55f9b9e8171e.png">

</br>

그럼 위와 같이 타입스크립트는 해당 값들을 보고 타입을 유추하고 유추한 타입으로 콜시그니쳐를 보여준다.</br>
여기서 타입스크립트는 T대신 타입스크립트가 발견한 타입으로 바꿔준다.</br>
우리는 직접 타입을 적어주지않았음에도 타입스크립트는 우리가 했던 작업들을 똑같이 진행해주고있다.

</br>

### superPrint함수의 리턴값을 변경

<img width="338" alt="스크린샷 2022-12-16 오전 12 22 26" src="https://user-images.githubusercontent.com/94230809/207899043-faefc1cf-6896-4925-a1af-c95c3101438f.png">

</br>
이때 우리는 콜 시그니쳐에서 void를 T로 바꿔준다.

</br>
<img width="153" alt="스크린샷 2022-12-16 오전 12 23 37" src="https://user-images.githubusercontent.com/94230809/207899328-7618be03-c73d-4fc5-af88-0d4c09c8535d.png">

</br>
이유는 이제 함수가 T의배열을 받고 T중 하나를 리턴하도록했기 때문이다.

그렇게 한 후 우리는 아래와 같이 함수를 변수에 담고 해당 변수의 타입을 확인해보면 이렇게 된걸 볼 수 있다.

<img width="320" alt="스크린샷 2022-12-16 오전 12 25 35" src="https://user-images.githubusercontent.com/94230809/207899861-771ef8c5-bb3e-4fd1-9421-e62f7c88ddce.png"></br>
<img width="321" alt="스크린샷 2022-12-16 오전 12 25 28" src="https://user-images.githubusercontent.com/94230809/207899874-5bb58693-cc7c-485b-a8c2-9768bed3eb37.png"></br>
<img width="321" alt="스크린샷 2022-12-16 오전 12 25 22" src="https://user-images.githubusercontent.com/94230809/207899881-c26c469c-4299-4e4c-93c9-daabd5ba703e.png"></br>
<img width="315" alt="스크린샷 2022-12-16 오전 12 25 16" src="https://user-images.githubusercontent.com/94230809/207899886-62e6b625-f5f3-4c43-998a-fbd09b014b45.png">
</br>
</br>

우리가 지금 한 것은 타입스크립트에게 타입을 유추하도록 알려주고 타입의 배열이 될 것이라는 것을 인지하고 그 타입중 하나를 리턴하도록 한것이다.
</br>
나머지는 타입스크립트가 알아서 하는것이다.
</br>타입스크립트는 보다시피 모든 콜시그니쳐를 대체하고 다르게 만든다.
</br>
우린 이렇게 전부 하나하나 적을필요없이 제네릭을 사용해서 해결할 수 있다

</br>

### 제네릭을 하나 더 추가하고싶을때는 어떻게 해야할까 ?

다시 우리는 제네릭을 사용할거라고 <>를 통해 얘기하고 이름을 작성하면되는데 하나 더 추가할거기때문에 다른이름으로 하나 더 추가하면된다.
</br>

그리고 어디서 이 제네릭을 사용할것인지 적으면되는데 제네릭이 함수의 두번째 인자를 사용할 거라고 얘기할 것이다.</br>

타입스크립트는 제네릭이 처음 사용되는 지점을 기반으로 타입이 무엇인지 알게된다.</br>

타입스크립트는 제네릭을 처음 인식했을 때와 제네릭의 순서를 기반으로 제네릭의 타입을 알게된다.</br>

<img width="702" alt="스크린샷 2022-12-16 오전 12 32 15" src="https://user-images.githubusercontent.com/94230809/207901454-f943f44d-1c9a-4681-a603-7a6b3f106e89.png">

</br>

우리는 지금 <T,M>을 통해 2개의 제네릭을 사용할것이라고 명시했고 T는 함수의 첫번째 파라미터로 배열이 올것이라고 말했고 M은 두번째 파라미터로 들어온다고 얘기한것이다.</br>

그리고 함수를 호출할때 해당 요청에 따라서 타입스크립트는 콜시그니쳐를 생성한다.
